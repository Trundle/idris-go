{-# LANGUAGE OverloadedStrings #-}

module IRTS.CodegenGo (codegenGo) where

import Control.Monad.Trans.State
import qualified Data.Map.Strict as M
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Data.Char (isAlphaNum)
import Data.Maybe (fromMaybe)
import Formatting ((%), int, sformat, stext)

import Idris.Core.TT hiding (arity)
import IRTS.Bytecode
import IRTS.CodegenCommon
import IRTS.Lang (LVar(..))
import IRTS.Simplified (SDecl(..))


data FunState = FunState { nLocals :: Int
                         , base :: Int
                         , top :: Int
                         }
emptyFunState :: Int -> FunState
emptyFunState arity = FunState { nLocals = arity, base = 0, top = arity }

type Fun a = State FunState a


goPreamble :: T.Text
goPreamble = T.unlines
  [ "// THIS FILE IS AUTOGENERATED! DO NOT EDIT"
  , ""
  , "package main"
  , ""
  , "import \"unsafe\""
  , ""
  ]


mangleName :: Name -> T.Text
mangleName name = T.map mangleChar (T.pack (showCG name))
  where
    mangleChar x
      | isAlphaNum x = x
      | otherwise = '_'

nameToGo :: Name -> T.Text
nameToGo (MN i n) | T.all (\x -> isAlphaNum x || x == '_') n =
                    n `T.append` T.pack (show i)
nameToGo n = mangleName n


regToVarName :: Reg -> Fun T.Text
regToVarName (RVal) = return "__rval"
regToVarName (L i) = do
  lBase <- gets base
  return $ sformat ("_" % int) (lBase + i)
regToVarName (T i) = do
  t <- gets top
  return $ sformat ("_" % int) (t + i)


codeToGo :: BC -> Fun T.Text

codeToGo (RESERVE n) = do
  currentLocals <- gets nLocals
  modify (\s -> s { nLocals = currentLocals + n })
  let vars = [sformat ("_" % int) i | i <- [currentLocals + 1..currentLocals + n]]
  return $ "var " `T.append` T.intercalate ", " vars `T.append` " unsafe.Pointer\n"

codeToGo (ADDTOP n) = do
  modify (\s -> s { top = top s + n })
  return T.empty

codeToGo (ASSIGN a b) = do
  varName <- regToVarName a
  valueName <- regToVarName b
  return $ varName `T.append` " = " `T.append` valueName `T.append` "\n"

codeToGo (BASETOP n) = do
  modify (\s -> s { base = top s + n })
  return T.empty

codeToGo (TOPBASE n) = do
  modify (\s -> s { top = base s + n })
  return T.empty

codeToGo (CALL n) = do
  funState <- get
  let arity = nLocals funState - base funState
  args <- sequence [regToVarName (L i) | i <- [0..arity]]
  return $ "__rval = " `T.append` nameToGo n `T.append` "(" `T.append` T.intercalate ", " args `T.append` ")\n"

codeToGo (NULL r) = do
  varName <- regToVarName r
  return $ varName `T.append` " = nil\n"

codeToGo c = return $ "// XXX not implemented yet: " `T.append` T.pack (show c) `T.append` "\n"


funToGo :: Name -> [BC] -> Int -> T.Text
funToGo name code arity = T.concat
  [ "func "
  , nameToGo name
  , "("
  , T.intercalate ", " [ sformat ("_" % int % " unsafe.Pointer") i | i <- [0..arity]]
  , ") unsafe.Pointer {\n    var __rval unsafe.Pointer\n"
  , body
  , "\n    return __rval\n}\n\n"
  ]
  where
    body = T.concat $ evalState (traverse codeToGo code) (emptyFunState arity)

genMain :: T.Text
genMain = "func main() { runMain0() }"

codegenGo :: CodeGenerator
codegenGo ci =
  let byteCode = map toBC (simpleDecls ci)
      arities = M.fromList [(n, length args) | (_, SFun n args _ _) <- simpleDecls ci]
  in
  TIO.writeFile (outputFile ci) $ T.concat
  [ goPreamble
  , T.concat (map (\(n, code) -> funToGo n code (fromMaybe 0 $ M.lookup n arities)) byteCode)
  , genMain
  ]
